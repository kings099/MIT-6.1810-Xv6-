RISC-V 汇编 (RISC-V assembly)
1. 函数参数寄存器
问题：哪些寄存器包含函数参数？例如，在main对printf的调用中，哪个寄存器持有13？

回答：
根据RISC-V的调用约定，前八个整数或指针类型的函数参数通过寄存器 a0 到 a7 传递。

a0 通常用于第一个参数（例如，printf中的格式化字符串地址）。

a1 用于第二个参数，a2 用于第三个，以此类推。

在main对printf的调用 printf("%d %d %d\n", f(8)+1, g(f(8)), 13) 中，参数的顺序是：

格式化字符串 "%d %d %d\n" 的地址（在 a0 中）。

f(8)+1 的计算结果（在 a1 中）。

g(f(8)) 的计算结果（在 a2 中）。

整数 13（在 a3 中）。

因此，持有13的是 a3 寄存器。

2. 函数调用位置
问题：在main的汇编代码中，对函数f的调用在哪里？对g的调用在哪里？（提示：编译器可能会内联函数。）

回答：
在main的汇编代码中，找不到对函数f或g的直接调用（如 jal 或 jalr 指令）。

原因是编译器进行了**内联（inlining）**优化。因为f(x)和g(x)这两个函数非常简单（分别是x+1和x*2），编译器为了避免函数调用的开销（保存和恢复寄存器、跳转等），直接将它们的函数体嵌入到了main函数中。

f(8)+1 在编译时被直接计算为 (8+1)+1 = 10。

g(f(8)) 被计算为 g(9)，即 9*2 = 18。

所以，在汇编代码里，你只会看到将立即数10、18和13加载到寄存器a1、a2和a3中的指令，而没有对f和g的函数调用。

3. printf 函数地址
问题：printf函数位于哪个地址？

回答：
printf函数的具体地址可以在user/call.asm文件中找到。通常，对库函数的调用不是一个简单的jal <绝对地址>指令。在汇编代码中，调用printf是通过jalr（jump and link register）指令完成的。通过观察jalr指令和它前面通常配对的auipc指令，可以推断出printf的地址。

在call.asm的main函数中，调用printf的部分看起来类似这样：

代码段

    auipc   a0, %pcrel_hi(LC0)
    addi    a0, a0, %pcrel_lo(L..2)
    ...
    jalr    -50(ra) # printf@plt
这里的jalr指令跳转到了printf函数。要找到确切的地址，你需要查看链接器生成的最终可执行文件的符号表，或者在GDB中调试并打印printf的地址。在call.asm中，printf@plt的注释表明它是一个通过过程链接表（PLT）进行的调用。

4. ra 寄存器的值
问题：在main中对printf的jalr调用之后，ra寄存器中的值是什么？

回答：
jalr（或jal）指令的“link”部分的作用，就是将紧随跳转指令之后的那条指令的地址保存到返回地址寄存器**ra**中。这样做是为了让被调用的函数（这里是printf）在执行完毕后，知道应该返回到哪里继续执行。

因此，ra寄存器中的值就是main函数里那条jalr指令正下方紧邻的下一条指令的地址。你可以在call.asm文件中找到这条jalr指令，它下一行指令的地址就是存入ra的值。

5. 字节序 (Endianness) 与 printf
问题：运行代码 unsigned int i = 0x00646c72; printf("H%x Wo%s", 57616, (char *) &i); 的输出是什么？如果RISC-V是big-endian，i应设置成什么才能得到相同输出？57616需要改变吗？

回答：

输出是什么?

%x 会将十进制数 57616 以十六进制形式打印，即 E110。

RISC-V是小端序（little-endian），整数0x00646c72在内存中从低地址到高地址依次存放为 72 6c 64 00。

%s将&i当作字符串地址，依次读取字节直到遇到\0 (即00)。根据ASCII码，0x72是'r'，0x6c是'l'，0x64是'd'。

所以，%s会打印出字符串 "rld"。

组合起来的最终输出是：HE110 World。

如果是Big-endian，i应设置成什么?
为了在内存中得到 72 6c 64 00 的字节序列，在大端序（big-endian）机器上，整数的值必须与内存序列完全相同。所以，i 应该被设置为 0x726c6400。

57616需要改变吗?
不需要。57616这个值是作为函数参数传递的，通常是通过寄存器。字节序主要影响多字节数据在内存中的存储顺序，而不影响整数值本身在寄存器中的表示。

6. printf 缺失参数
问题：在代码 printf("x=%d y=%d", 3); 中，y=后面会打印什么？为什么？

回答：

y=后面会打印什么?
它会打印一个不确定的、随机的垃圾值。

为什么会这样?
printf函数本身不知道被调用时传递了多少个参数。它完全依赖于格式化字符串（第一个参数）来决定需要从哪里获取后续参数。

格式化字符串 "x=%d y=%d" 中有两个 %d，所以printf认为它应该接收两个整数参数。

它正确地从a1寄存器中取出第一个参数3并打印出来。

然后，它会尝试从下一个参数寄存器（即a2）中获取第二个整数。

由于调用者只传递了一个参数3，并没有向a2寄存器中放入任何值，所以a2寄存器中保留着上一次某个无关操作留下的**“垃圾”数据**。

printf盲目地将这个垃圾数据当作一个整数打印了出来，导致了不确定的输出。