实验一：检查用户进程页表 (Inspect a user-process page table)
问题: 对于 print_pgtbl 输出中的每一个页表项，解释它在逻辑上包含了什么，以及它的权限位是什么。

回答:

print_pgtbl 的输出展示了进程地址空间中几个关键页面的映射情况。每个页表项（PTE）都定义了一个虚拟地址到物理地址的映射，并附加了一系列权限。以下是逐行分析：

va 0 pte 0x21FCF45B pa 0x87F3D000 perm 0x5B

逻辑内容: 这是进程的用户代码段（.text）。它是程序的指令所在，从虚拟地址 0 开始。

权限位 (perm 0x5B): 解码 0x5B 得到 01011011。关键的权限位是 PTE_V (Valid), PTE_R (Read), PTE_X (Execute), PTE_U (User), PTE_A (Accessed), PTE_D (Dirty)。用户代码应该是可读、可执行的，并且允许用户模式访问。

va 1000 pte 0x21FCE85B pa 0x87F3A000 perm 0x5B

逻辑内容: 这仍然是进程的用户代码段。由于一个页面是 4KB (0x1000 字节)，虚拟地址 0x1000 是代码段的第二个页面。

权限位 (perm 0x5B): 与上面相同，是可读、可执行、用户可访问的。

va 0xFFFFD000 pte 0x0 pa 0x0 perm 0x0

逻辑内容: 这是一个哨兵页 (Guard Page)。它位于用户栈的下方，是一个未映射的页面。

权限位 (perm 0x0): PTE_V 位为0，表示这个页表项无效。任何对该地址的访问都会立即触发页面错误（page fault），从而防止栈溢出后意外地破坏了堆或其他数据。

va 0xFFFFE000 pte 0x21FD80C7 pa 0x87F60000 perm 0xC7

逻辑内容: 这是用户栈 (User Stack)。栈是从高地址向低地址增长的，这个页面是栈的最高处。

权限位 (perm 0xC7): 解码 0xC7 得到 11000111。权限包括 PTE_V, PTE_R, PTE_W (Write), PTE_U。用户栈必须是可读、可写的，并且允许用户模式访问，但不可执行，以防止代码注入攻击。

va 0xFFFFF000 pte 0x20001C4B pa 0x80007000 perm 0x4B

逻辑内容: 这是陷阱帧 (Trapframe) 页。当进程从用户模式切换到内核模式时，内核会在这里保存进程的所有寄存器状态。

权限位 (perm 0x4B): 解码 0x4B 得到 01001011。权限为 PTE_V, PTE_R, PTE_X。注意，它没有 PTE_U 位，意味着这个页面只允许内核模式访问，用户代码无法直接读写，保证了系统的安全性。

实验二：加速系统调用 (Speed up system calls)
问题: 除了 getpid()，还有哪些 xv6 系统调用可以用这个共享页面来加速？请解释如何实现。

回答:

任何返回进程自身、不常变动、且不依赖复杂计算或外部输入的简单状态信息的系统调用，都可以用这种方式加速。基本思路是在 struct usyscall 结构体中增加新的字段，并在进程创建时（如 allocproc）或相关信息更新时维护这些字段。

getppid() (获取父进程ID)

原因: 父进程ID (PPID) 在一个进程的生命周期中通常是不变的（除非父进程退出，进程被 init 进程接管，但这可以通过在 reparent 中更新该值来解决）。

如何实现: 在 struct usyscall 中增加一个 int ppid 字段。在 allocproc 中，当设置子进程的 p->parent 时，同时将父进程的PID写入子进程共享页的 ppid 字段。

uptime() (获取系统自启动以来的时间)

原因: 这个值虽然在变，但内核无论如何都会在每次时钟中断时更新一个全局的 ticks 计数器。让所有进程都陷入内核来读取同一个值是低效的。

如何实现: 可以在 struct usyscall 中增加一个 uint ticks 字段。在内核的时钟中断处理函数中，除了更新全局的 ticks 变量，还可以循环所有进程（或通过其他机制），更新它们共享页中的 ticks 值。用户空间的 uptime() 就可以直接读取这个值。

更优化的实现：创建一个全局的只读共享页，映射到所有进程的地址空间。内核只需更新这一个页面，所有进程都能看到最新的 uptime，避免了为每个进程单独更新。

实验三：打印页表 (Print a page table)
问题: 对于 vmprint 输出中的每一个叶子页，解释它在逻辑上包含了什么，它的权限位是什么，以及它与上一个练习 print_pgtbl() 的输出有何关系。

回答:

vmprint 的输出是 print_pgtbl 宏观视图的底层实现细节。print_pgtbl 告诉我们“这里是用户代码”，而 vmprint 则展示了“为了映射用户代码，我们设置了这样一个三级页表结构，最终的L0页表项指向某物理地址，并赋予了R-X-U权限”。

以下是 vmprint 示例输出中关键叶子节点（即最终指向数据页的PTE）的分析：

.. .. ..0x0000000000000000: pte ...5b pa ...

逻辑内容: 这是用户代码 (.text) 的第一个页面。

权限位: 解码 PTE (例如 ...5b) 得到 PTE_V, PTE_R, PTE_X, PTE_U。

关系: 这正是 print_pgtbl 中 va 0 那一行所代表的映射的底层实现。

.. .. ..0x0000000000001000: pte ...d7 pa ...

逻辑内容: 可能是用户代码的后续部分，或者是用户数据 (.data) 或堆 (heap) 的开始。

权限位: 解码 PTE (例如 ...d7) 得到 PTE_V, PTE_R, PTE_W, PTE_U (可读可写)。

关系: 对应 print_pgtbl 中用户地址空间中较低地址的某个数据页。

.. .. ..0xffffffffffffd000: pte ...13 pa ...

逻辑内容: 内核数据或内核栈。位于极高的虚拟地址。

权限位: 解码 PTE (例如 ...13) 得到 PTE_V, PTE_R, PTE_W (可读可写)，但没有 PTE_U，禁止用户访问。

关系: 这是 print_pgtbl 无法直接展示的内核空间映射的细节。

.. .. ..0xffffffffffffe000: pte ...c7 pa ...

逻辑内容: 内存映射的I/O设备，例如 PLIC 或 CLINT。

权限位: PTE_V, PTE_R, PTE_W，同样禁止用户访问。

关系: 对应 print_pgtbl 中 va 0xFFFFE000 行的底层实现。

.. .. ..0xfffffffffffff000: pte ...4b pa ...

逻辑内容: 内核代码 (.text)。

权限位: PTE_V, PTE_R, PTE_X，可读可执行，禁止用户访问。

关系: 对应 print_pgtbl 中 va 0xFFFFF000 行的底层实现。